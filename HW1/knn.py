# q0 load all the images
# q1 use kmeans clustering to create a color table
# q2 compute the distances between the color table and the images
# q3 use knn to classify the images

import cv2
import itertools
from itertools import chain
from matplotlib.pylab import *
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
import numpy as np
import os
import pickle
import random
from scipy.spatial.distance import cdist
from sklearn.model_selection import train_test_split
from sklearn.cluster import KMeans
from sklearn.metrics import confusion_matrix
from sklearn.neighbors import KNeighborsClassifier


class Image:
    def __init__(self, path: str, label: str, rgb_iamge: cv2.Mat):
        self.path = path
        self.label = label
        self.rgb_image = rgb_iamge

        self.name = path.split("/")[-1]
        self.hsv_image = cv2.cvtColor(self.rgb_image, cv2.COLOR_BGR2HSV)
        self.flattened_hsv_image = self.hsv_image.reshape(-1, 3)


def load_images(root, from_pickle=False) -> dict[str, list[Image]]:
    """ """
    if from_pickle:
        print(f"Loading images from pickle...")

        with open("images.pickle", "rb") as f:
            images = pickle.load(f)
        return images

    print(f"Loading images from {root}...")
    folders = os.listdir(root)
    images: dict[str, list[Image]] = {}

    for label in folders[:15]:
        print(f"Loading {label} images...")
        if label not in images:
            images[label] = []

        for i, image in enumerate(random.choices(os.listdir(root + label), k=40)):
            img = cv2.imread(f"{root}{label}/{image}")
            images[label].append(
                Image(path=f"{root}{label}/{image}", label=label, rgb_iamge=img)
            )

    with open("images.pickle", "wb") as f:
        pickle.dump(images, f)

    return images


def get_color_table(
    images: dict[str, Image], num_pixels: int, num_clusters: int, from_pickle=False
) -> np.ndarray:
    """
    Computes or loads the color table for the given images.

    This function either loads the color table from a pickle file if the `from_pickle` flag is set to True, or computes the color table from the given images. The color table is generated by taking `num_pixels` randomly selected pixels from each image, and using KMeans clustering to find `num_clusters` center colors.

    Parameters
    ----------
    images : dict[str, Image]
        Dictionary containing labels and their corresponding images.
    num_pixels : int
        Number of pixels to use for generating the color table.
    num_clusters : int
        Number of clusters to use for KMeans clustering.
    from_pickle : bool, optional
        Flag to indicate whether to load the color table from pickle, by default False.

    Returns
    -------
    np.ndarray
        Computed or loaded color table.

    """
    if from_pickle:
        print(f"Loading color table from pickle...")

        with open("color_table.pickle", "rb") as f:
            color_table = pickle.load(f)
        return color_table

    print(f"Computing color table...")

    image_hsvs = np.empty((0, 3))
    for label in images:
        for image in images[label]:
            image_hsvs = np.vstack(
                (
                    image_hsvs,
                    random.choices(image.flattened_hsv_image, k=num_pixels),
                )
            )
    kmeans = KMeans(n_clusters=num_clusters, n_init=10)
    kmeans.fit(image_hsvs)

    min_hue = np.min(kmeans.cluster_centers_[:, 0])
    max_hue = np.max(kmeans.cluster_centers_[:, 0])
    min_saturation = np.min(kmeans.cluster_centers_[:, 1])
    max_saturation = np.max(kmeans.cluster_centers_[:, 1])
    min_value = np.min(kmeans.cluster_centers_[:, 2])
    max_value = np.max(kmeans.cluster_centers_[:, 2])
    print(f"Min Hue: {min_hue}")
    print(f"Max Hue: {max_hue}")
    print(f"Min Saturation: {min_saturation}")
    print(f"Max Saturation: {max_saturation}")
    print(f"Min Value: {min_value}")
    print(f"Max Value: {max_value}")

    cluster_centers = kmeans.cluster_centers_ / 255.0

    with open("color_table.pickle", "wb") as f:
        pickle.dump(cluster_centers, f)

    return cluster_centers


def get_HSV_hist(image: Image, color_table: np.ndarray) -> np.ndarray:
    """
    Computes the histogram of a given image in the HSV color space.

    Parameters
    ----------
    image : Image
        An instance of the Image class, which represents the image for which the histogram is to be computed.
    color_table : np.ndarray
        A numpy ndarray of shape (N, 3) where N is the number of color bins, representing the color table used for quantizing the image's HSV values.

    Returns
    -------
    np.ndarray
        A normalized histogram of the image in the form of a numpy ndarray of shape (N,). The normalization is performed by dividing the histogram values by the sum of all histogram values.

    Notes
    -----
    The computation of the histogram involves the following steps:

    - Flattening the image's HSV values.
    - Computing the euclidean distance between each pixel's HSV value and the color table.
    - Determining the color bin index for each pixel by finding the minimum euclidean distance.
    - Computing the histogram by counting the number of pixels in each color bin using the determined color bin indices.
    - Normalizing the histogram by dividing each bin count by the sum of all bin counts.
    """
    print(f"Computing HSV histogram for {image.name}...")

    distance = cdist(image.flattened_hsv_image, color_table, metric="euclidean")
    pixel_bin_index = np.argmin(distance, axis=1)
    histogram = np.bincount(pixel_bin_index, minlength=color_table.shape[0])

    return histogram / np.sum(histogram)


def classify_images(
    images: chain[Image],
    color_table: np.ndarray,
    train_test_split_percent: float = 0.8,
    n_neighbors: int = 5,
    plot_confusion_matrix: bool = False,
) -> float:
    """
    Classify images using a K-nearest neighbors (KNN) algorithm.

    Parameters:
    - images (chain[Image]): The images to classify.
    - color_table (np.ndarray): The color table used to compute the HSV histograms of the images.
    - train_test_split_percent (float, optional): The percentage of images to use for training. The remaining images will be used for testing. Defaults to 0.8.
    - n_neighbors (int, optional): The number of nearest neighbors to consider when classifying an image. Defaults to 5.

    Returns:
    - float: The accuracy of the classifier.

    Notes:
    - The function first computes the HSV histograms of the images using the `get_HSV_hist` function and the provided color table.
    - It then splits the images into a training set and a testing set using the `train_test_split_percent` argument.
    - The KNN classifier is then trained on the training set.
    - Finally, the accuracy of the classifier is computed by comparing its predictions on the testing set to the actual labels of the images.
    """
    print(f"Classifying images using KNN (K={n_neighbors})...")

    image_histograms: list[np.ndarray] = []
    labels: list[str] = []
    for image in images:
        image_histograms.append(get_HSV_hist(image, color_table))
        labels.append(image.label)
    train, test, train_labels, test_labels = train_test_split(
        image_histograms,
        labels,
        train_size=train_test_split_percent,
    )

    knn_classifier = KNeighborsClassifier(n_neighbors=n_neighbors)
    knn_classifier.fit(train, train_labels)

    correct = 0
    predictions = knn_classifier.predict(test)
    for i, prediction in enumerate(predictions):
        if prediction == test_labels[i]:
            correct += 1

    accuracy = correct / len(predictions)

    if plot_confusion_matrix:
        cm = confusion_matrix(test_labels, knn_classifier.predict(test))

        plt.imshow(cm, interpolation="nearest", cmap=plt.cm.Blues)
        plt.title(f"Confusion Matrix (K={n_neighbors}) - Accuracy: {accuracy:.2f}")
        plt.colorbar()
        tick_marks = np.arange(len(set(labels)))
        plt.xticks(tick_marks, set(labels), rotation=90)
        plt.yticks(tick_marks, set(labels))

        cm = cm.astype("float") / cm.sum(axis=1)[:, np.newaxis]
        thresh = cm.max() / 2.0
        for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):
            plt.text(
                j,
                i,
                f"{cm[i, j]:.2f}",
                horizontalalignment="center",
                color="white" if cm[i, j] > thresh else "black",
            )

        plt.tight_layout()
        plt.ylabel("True label")
        plt.xlabel("Predicted label")
        plt.show()

    return accuracy


if __name__ == "__main__":
    nwpu_path = os.path.join(os.path.dirname(__file__), "../NWPU-RESISC45/")
    image_shape = (256, 256)
    percentage_of_pixels = 0.01
    num_pixels_to_use = int(image_shape[0] * image_shape[1] * percentage_of_pixels)
    num_clusters = 64

    LOAD_IMAGES = False
    COMPUTE_COLOR_TABLE = False or LOAD_IMAGES
    PLOT_COLOR_TABLE = False
    PLOT_KNN_CONFUSION_MATRIX = True

    images = load_images(nwpu_path, from_pickle=not LOAD_IMAGES)

    color_table = get_color_table(
        images=images,
        num_pixels=num_pixels_to_use,
        num_clusters=num_clusters,
        from_pickle=not COMPUTE_COLOR_TABLE,
    )

    # plot color table in 3d plot
    if PLOT_COLOR_TABLE:
        fig = plt.figure()
        ax = fig.add_subplot(111, projection="3d")
        ax.scatter(color_table[:, 0], color_table[:, 1], color_table[:, 2])
        ax.set_xlabel("Hue")
        ax.set_ylabel("Saturation")
        ax.set_zlabel("Value")
        plt.show()

    classification_accuracy = classify_images(
        images=chain(*images.values()),
        color_table=color_table,
        plot_confusion_matrix=PLOT_KNN_CONFUSION_MATRIX,
    )
    print(f"Classification Accuracy: {classification_accuracy}")

    print("DONE")
